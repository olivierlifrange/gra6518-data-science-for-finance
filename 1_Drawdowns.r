
#
#  Dradown.r hello
#
#  Study the distribution of drawdowns in a simple set-up  
#  
# Assumes log returns are generated by r(t) = m(t) + s*e(t),   where e(t)  is N(0,1) 
# Generates a long series of drawdowns to study their depth and duration distribution.
#
#  Paolo Giordani, August 2020

setwd("C:/Users/admin/OneDrive - BI Norwegian Business School (BIEDU)/BI/GRA 6518 Data Science for Finance/R files")

#  Options on data-generating process, strategy, and simulation
 
m		  =  0.0055   # e.g. 0.0085 for nominal returns and 0.0055 for excess returns
s     =  0.035    # e.g. 0.035 for SP500
lev   =  0.9      # e.g. 1. leverage of the strategy (approximate calculation). 1 for fully invested, 2 for 100% leverage, 0.5 for 50% in cash

bigT	=  100000    # sample size to simulate. A large number

nobsPlot = 50*12  # plot the first 50 years of drawdowns

set.seed(123)     # set seed for random number generator so outcome is the same for every run

# generate a (bigT,1) series of returns. For this simple model, no loop is needed.

r   = m + s*rnorm(bigT)            # generate log returns for underlying asset, a (bigT,1) vector. rnorm generates a (bigT,1) vector of iid N(0,1) variables

Rst	= lev*(exp(r)-1)               # return of the strategy. R = exp(r)-1 -> we go from the log returns to the returns!!


DD   = matrix(0.0,bigT,1)           # pre-allocate matrix to store drawdowns.
DDd  = matrix(1.0,bigT,1)          # pre-allocate matrix to store dradowns durations

# This simple implementation works if bigT is not too large. If bigT is large, using logs of total value is much more stable numerically
# Let's see the simple version first ...

# V    = cumprod(1 + Rst)             # total value of the strategy is the cumulative product of returns, initialized at V[0] = 1
# 
# maxV = V[1]                         # initializing max(V[1:t]). Keeping track of maxV within the loop is much much faster than recomputing it each time 
#  
# for (t in 2:bigT){                  
#    DD[t] = min(c(1.0,V[t]/maxV)) - 1.0    
#    maxV  = max(c(V[t],maxV))       # the following would work but is poor coding:  for (t in 2:bigT){ maxV = max(V[1:t]) ... Here we keep track of maxV within the loop
# 
#    if (DD[t]==0){ DDd[t] = 0 } else if (DD[t]<0) { DDd[t] = DDd[t-1] +1 } # update drawdown length. If we are in a drawdown, then its length is increased by one. If we are not, DDd is re-set to zero.         
#    }

 
# The next implementation is more stable for large bigT: work with log values, then transform back. 
maxlogV	= 0                   # starting value for highest log(V)
logV    = cumsum(log(1+Rst))  # log(V), but built without creating V, which can become a very large number (creating numerical problems) in simulation

for (t in 2:bigT){                  
  DD[t]    = min(c(1.0,exp(logV[t]- maxlogV)  )) - 1.0    
  maxlogV  = max(c(logV[t],maxlogV))       
  
  if (DD[t]==0){ DDd[t] = 0 } else if (DD[t]<0) { DDd[t] = DDd[t-1] +1 } # update drawdown length. If we are in a drawdown, then its length is increased by one. If we are not, DDd is re-set to zero.         
}


# print some statistics

print(" yearly mean, std and Sharpe ratio of log returns (assuming monthly frequency) ") 
st = c(12*m,sqrt(12)*s,sqrt(12)*m/s)
print(st,digits = 2)

qv 	= c(0.01,0.05,0.10,0.50)        # some quantiles of drawdown values
qd	= c(0.50,0.90,0.95,0.99)       # some quantiles of drawdown duration

print(" Drawdowns quantiles and values in % ")
print(quantile(DD*100,qv),digits=2)              # multiply by 100 to get % drawdown

print(" Drawdown duration quantiles ")
print(quantile(DDd,qd),digits=2)

print(" Share of the time spent in a drawdown")
print(mean(DD < 0),digits=2)


# plot some of simulated drawdowns
pt01 <- 'simulated drawdowns'
plot(sequence(nobsPlot),DD[1:nobsPlot], type = 'l', main = pt01, xlab = 'observation', ylab = 'drawdown' ,col = 'red', lwd = 2)
